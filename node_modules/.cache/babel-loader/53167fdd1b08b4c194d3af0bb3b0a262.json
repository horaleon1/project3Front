{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst path = require('path');\n\nlet parsePath = path.parse;\nlet SEP = path.sep ||\n/* istanbul ignore next */\n'/';\nconst origParser = parsePath;\nconst origSep = SEP;\n\nfunction makeRelativeNormalizedPath(str, sep) {\n  const parsed = parsePath(str);\n  let root = parsed.root;\n  let dir;\n  let file = parsed.base;\n  let quoted;\n  let pos; // handle a weird windows case separately\n\n  if (sep === '\\\\') {\n    pos = root.indexOf(':\\\\');\n\n    if (pos >= 0) {\n      root = root.substring(0, pos + 2);\n    }\n  }\n\n  dir = parsed.dir.substring(root.length);\n\n  if (str === '') {\n    return [];\n  }\n\n  if (sep !== '/') {\n    quoted = new RegExp(sep.replace(/\\W/g, '\\\\$&'), 'g');\n    dir = dir.replace(quoted, '/');\n    file = file.replace(quoted, '/'); // excessively paranoid?\n  }\n\n  if (dir !== '') {\n    dir = dir + '/' + file;\n  } else {\n    dir = file;\n  }\n\n  if (dir.substring(0, 1) === '/') {\n    dir = dir.substring(1);\n  }\n\n  dir = dir.split(/\\/+/);\n  return dir;\n}\n\nfunction Path(strOrArray) {\n  if (Array.isArray(strOrArray)) {\n    this.v = strOrArray;\n  } else if (typeof strOrArray === 'string') {\n    this.v = makeRelativeNormalizedPath(strOrArray, SEP);\n  } else {\n    throw new Error('Invalid Path argument must be string or array:' + strOrArray);\n  }\n}\n\nPath.prototype.toString = function () {\n  return this.v.join('/');\n};\n\nPath.prototype.hasParent = function () {\n  return this.v.length > 0;\n};\n\nPath.prototype.parent = function () {\n  if (!this.hasParent()) {\n    throw new Error('Unable to get parent for 0 elem path');\n  }\n\n  const p = this.v.slice();\n  p.pop();\n  return new Path(p);\n};\n\nPath.prototype.elements = function () {\n  return this.v.slice();\n};\n\nPath.prototype.contains = function (other) {\n  let i;\n\n  if (other.length > this.length) {\n    return false;\n  }\n\n  for (i = 0; i < other.length; i += 1) {\n    if (this.v[i] !== other.v[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nPath.prototype.ancestorOf = function (other) {\n  return other.contains(this) && other.length !== this.length;\n};\n\nPath.prototype.descendantOf = function (other) {\n  return this.contains(other) && other.length !== this.length;\n};\n\nPath.prototype.commonPrefixPath = function (other) {\n  const len = this.length > other.length ? other.length : this.length;\n  let i;\n  const ret = [];\n\n  for (i = 0; i < len; i += 1) {\n    if (this.v[i] === other.v[i]) {\n      ret.push(this.v[i]);\n    } else {\n      break;\n    }\n  }\n\n  return new Path(ret);\n};\n\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(f => {\n  Path.prototype[f] = function (...args) {\n    const v = this.v;\n    return v[f](...args);\n  };\n});\n\nPath.compare = function (a, b) {\n  const al = a.length;\n  const bl = b.length;\n\n  if (al < bl) {\n    return -1;\n  }\n\n  if (al > bl) {\n    return 1;\n  }\n\n  const astr = a.toString();\n  const bstr = b.toString();\n  return astr < bstr ? -1 : astr > bstr ? 1 : 0;\n};\n\nObject.defineProperty(Path.prototype, 'length', {\n  enumerable: true,\n\n  get() {\n    return this.v.length;\n  }\n\n});\nmodule.exports = Path;\nPath.tester = {\n  setParserAndSep(p, sep) {\n    parsePath = p;\n    SEP = sep;\n  },\n\n  reset() {\n    parsePath = origParser;\n    SEP = origSep;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}