{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst util = require('util');\n\nconst coverage = require('istanbul-lib-coverage');\n\nconst Path = require('./path');\n\nconst tree = require('./tree');\n\nconst BaseNode = tree.Node;\nconst BaseTree = tree.Tree;\n\nfunction ReportNode(path, fileCoverage) {\n  this.path = path;\n  this.parent = null;\n  this.fileCoverage = fileCoverage;\n  this.children = [];\n}\n\nutil.inherits(ReportNode, BaseNode);\n\nReportNode.prototype.addChild = function (child) {\n  child.parent = this;\n  this.children.push(child);\n};\n\nReportNode.prototype.asRelative = function (p) {\n  /* istanbul ignore if */\n  if (p.substring(0, 1) === '/') {\n    return p.substring(1);\n  }\n\n  return p;\n};\n\nReportNode.prototype.getQualifiedName = function () {\n  return this.asRelative(this.path.toString());\n};\n\nReportNode.prototype.getRelativeName = function () {\n  const parent = this.getParent();\n  const myPath = this.path;\n  let relPath;\n  let i;\n  const parentPath = parent ? parent.path : new Path([]);\n\n  if (parentPath.ancestorOf(myPath)) {\n    relPath = new Path(myPath.elements());\n\n    for (i = 0; i < parentPath.length; i += 1) {\n      relPath.shift();\n    }\n\n    return this.asRelative(relPath.toString());\n  }\n\n  return this.asRelative(this.path.toString());\n};\n\nReportNode.prototype.getParent = function () {\n  return this.parent;\n};\n\nReportNode.prototype.getChildren = function () {\n  return this.children;\n};\n\nReportNode.prototype.isSummary = function () {\n  return !this.fileCoverage;\n};\n\nReportNode.prototype.getFileCoverage = function () {\n  return this.fileCoverage;\n};\n\nReportNode.prototype.getCoverageSummary = function (filesOnly) {\n  const cacheProp = 'c_' + (filesOnly ? 'files' : 'full');\n  let summary;\n\n  if (this.hasOwnProperty(cacheProp)) {\n    return this[cacheProp];\n  }\n\n  if (!this.isSummary()) {\n    summary = this.getFileCoverage().toSummary();\n  } else {\n    let count = 0;\n    summary = coverage.createCoverageSummary();\n    this.getChildren().forEach(child => {\n      if (filesOnly && child.isSummary()) {\n        return;\n      }\n\n      count += 1;\n      summary.merge(child.getCoverageSummary(filesOnly));\n    });\n\n    if (count === 0 && filesOnly) {\n      summary = null;\n    }\n  }\n\n  this[cacheProp] = summary;\n  return summary;\n};\n\nfunction treeFor(root, childPrefix) {\n  const tree = new BaseTree();\n\n  const maybePrefix = function (node) {\n    if (childPrefix && !node.isRoot()) {\n      node.path.unshift(childPrefix);\n    }\n  };\n\n  tree.getRoot = function () {\n    return root;\n  };\n\n  const visitor = {\n    onDetail(node) {\n      maybePrefix(node);\n    },\n\n    onSummary(node) {\n      maybePrefix(node);\n      node.children.sort((a, b) => {\n        const astr = a.path.toString();\n        const bstr = b.path.toString();\n        return astr < bstr ? -1 : astr > bstr ? 1 :\n        /* istanbul ignore next */\n        0;\n      });\n    }\n\n  };\n  tree.visit(visitor);\n  return tree;\n}\n\nfunction findCommonParent(paths) {\n  if (paths.length === 0) {\n    return new Path([]);\n  }\n\n  let common = paths[0];\n  let i;\n\n  for (i = 1; i < paths.length; i += 1) {\n    common = common.commonPrefixPath(paths[i]);\n\n    if (common.length === 0) {\n      break;\n    }\n  }\n\n  return common;\n}\n\nfunction toInitialList(coverageMap) {\n  const ret = [];\n  coverageMap.files().forEach(filePath => {\n    const p = new Path(filePath);\n    const coverage = coverageMap.fileCoverageFor(filePath);\n    ret.push({\n      filePath,\n      path: p,\n      fileCoverage: coverage\n    });\n  });\n  const commonParent = findCommonParent(ret.map(o => o.path.parent()));\n\n  if (commonParent.length > 0) {\n    ret.forEach(o => {\n      o.path.splice(0, commonParent.length);\n    });\n  }\n\n  return {\n    list: ret,\n    commonParent\n  };\n}\n\nfunction toDirParents(list) {\n  const nodeMap = Object.create(null);\n  const parentNodeList = [];\n  list.forEach(o => {\n    const node = new ReportNode(o.path, o.fileCoverage);\n    const parentPath = o.path.parent();\n    let parent = nodeMap[parentPath.toString()];\n\n    if (!parent) {\n      parent = new ReportNode(parentPath);\n      nodeMap[parentPath.toString()] = parent;\n      parentNodeList.push(parent);\n    }\n\n    parent.addChild(node);\n  });\n  return parentNodeList;\n}\n\nfunction foldIntoParents(nodeList) {\n  const ret = [];\n  let i;\n  let j; // sort by longest length first\n\n  nodeList.sort((a, b) => -1 * Path.compare(a.path, b.path));\n\n  for (i = 0; i < nodeList.length; i += 1) {\n    const first = nodeList[i];\n    let inserted = false;\n\n    for (j = i + 1; j < nodeList.length; j += 1) {\n      const second = nodeList[j];\n\n      if (second.path.ancestorOf(first.path)) {\n        second.addChild(first);\n        inserted = true;\n        break;\n      }\n    }\n\n    if (!inserted) {\n      ret.push(first);\n    }\n  }\n\n  return ret;\n}\n\nfunction createRoot() {\n  return new ReportNode(new Path([]));\n}\n\nfunction createNestedSummary(coverageMap) {\n  const flattened = toInitialList(coverageMap);\n  const dirParents = toDirParents(flattened.list);\n  const topNodes = foldIntoParents(dirParents);\n\n  if (topNodes.length === 0) {\n    return treeFor(new ReportNode(new Path([])));\n  }\n\n  if (topNodes.length === 1) {\n    return treeFor(topNodes[0]);\n  }\n\n  const root = createRoot();\n  topNodes.forEach(node => {\n    root.addChild(node);\n  });\n  return treeFor(root);\n}\n\nfunction createPackageSummary(coverageMap) {\n  const flattened = toInitialList(coverageMap);\n  const dirParents = toDirParents(flattened.list);\n  const common = flattened.commonParent;\n  let prefix;\n  let root;\n\n  if (dirParents.length === 1) {\n    root = dirParents[0];\n  } else {\n    root = createRoot(); // if one of the dirs is itself the root,\n    // then we need to create a top-level dir\n\n    dirParents.forEach(dp => {\n      if (dp.path.length === 0) {\n        prefix = 'root';\n      }\n    });\n\n    if (prefix && common.length > 0) {\n      prefix = common.elements()[common.elements().length - 1];\n    }\n\n    dirParents.forEach(node => {\n      root.addChild(node);\n    });\n  }\n\n  return treeFor(root, prefix);\n}\n\nfunction createFlatSummary(coverageMap) {\n  const flattened = toInitialList(coverageMap);\n  const list = flattened.list;\n  const root = createRoot();\n  list.forEach(o => {\n    const node = new ReportNode(o.path, o.fileCoverage);\n    root.addChild(node);\n  });\n  return treeFor(root);\n}\n\nmodule.exports = {\n  createNestedSummary,\n  createPackageSummary,\n  createFlatSummary\n};","map":null,"metadata":{},"sourceType":"script"}