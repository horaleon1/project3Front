{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst util = require('util');\n/**\n * An object with methods that are called during the traversal of the coverage tree.\n * A visitor has the following methods that are called during tree traversal.\n *\n *   * `onStart(root, state)` - called before traversal begins\n *   * `onSummary(node, state)` - called for every summary node\n *   * `onDetail(node, state)` - called for every detail node\n *   * `onSummaryEnd(node, state)` - called after all children have been visited for\n *      a summary node.\n *   * `onEnd(root, state)` - called after traversal ends\n *\n * @param delegate - a partial visitor that only implements the methods of interest\n *  The visitor object supplies the missing methods as noops. For example, reports\n *  that only need the final coverage summary need implement `onStart` and nothing\n *  else. Reports that use only detailed coverage information need implement `onDetail`\n *  and nothing else.\n * @constructor\n */\n\n\nfunction Visitor(delegate) {\n  this.delegate = delegate;\n}\n\n['Start', 'End', 'Summary', 'SummaryEnd', 'Detail'].forEach(k => {\n  const f = 'on' + k;\n\n  Visitor.prototype[f] = function (node, state) {\n    if (this.delegate[f] && typeof this.delegate[f] === 'function') {\n      this.delegate[f].call(this.delegate, node, state);\n    }\n  };\n});\n\nfunction CompositeVisitor(visitors) {\n  if (!Array.isArray(visitors)) {\n    visitors = [visitors];\n  }\n\n  this.visitors = visitors.map(v => {\n    if (v instanceof Visitor) {\n      return v;\n    }\n\n    return new Visitor(v);\n  });\n}\n\nutil.inherits(CompositeVisitor, Visitor);\n['Start', 'Summary', 'SummaryEnd', 'Detail', 'End'].forEach(k => {\n  const f = 'on' + k;\n\n  CompositeVisitor.prototype[f] = function (node, state) {\n    this.visitors.forEach(v => {\n      v[f](node, state);\n    });\n  };\n});\n\nfunction Node() {}\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.getQualifiedName = function () {\n  throw new Error('getQualifiedName must be overridden');\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.getRelativeName = function () {\n  throw new Error('getRelativeName must be overridden');\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.isRoot = function () {\n  return !this.getParent();\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.getParent = function () {\n  throw new Error('getParent must be overridden');\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.getChildren = function () {\n  throw new Error('getChildren must be overridden');\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.isSummary = function () {\n  throw new Error('isSummary must be overridden');\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.getCoverageSummary = function ()\n/* filesOnly */\n{\n  throw new Error('getCoverageSummary must be overridden');\n};\n/* istanbul ignore next: abstract method */\n\n\nNode.prototype.getFileCoverage = function () {\n  throw new Error('getFileCoverage must be overridden');\n};\n/**\n * visit all nodes depth-first from this node down. Note that `onStart`\n * and `onEnd` are never called on the visitor even if the current\n * node is the root of the tree.\n * @param visitor a full visitor that is called during tree traversal\n * @param state optional state that is passed around\n */\n\n\nNode.prototype.visit = function (visitor, state) {\n  if (this.isSummary()) {\n    visitor.onSummary(this, state);\n  } else {\n    visitor.onDetail(this, state);\n  }\n\n  this.getChildren().forEach(child => {\n    child.visit(visitor, state);\n  });\n\n  if (this.isSummary()) {\n    visitor.onSummaryEnd(this, state);\n  }\n};\n/**\n * abstract base class for a coverage tree.\n * @constructor\n */\n\n\nfunction Tree() {}\n/**\n * returns the root node of the tree\n */\n\n/* istanbul ignore next: abstract method */\n\n\nTree.prototype.getRoot = function () {\n  throw new Error('getRoot must be overridden');\n};\n/**\n * visits the tree depth-first with the supplied partial visitor\n * @param visitor - a potentially partial visitor\n * @param state - the state to be passed around during tree traversal\n */\n\n\nTree.prototype.visit = function (visitor, state) {\n  if (!(visitor instanceof Visitor)) {\n    visitor = new Visitor(visitor);\n  }\n\n  visitor.onStart(this.getRoot(), state);\n  this.getRoot().visit(visitor, state);\n  visitor.onEnd(this.getRoot(), state);\n};\n\nmodule.exports = {\n  Tree,\n  Node,\n  Visitor,\n  CompositeVisitor\n};","map":null,"metadata":{},"sourceType":"script"}